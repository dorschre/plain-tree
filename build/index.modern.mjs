const t=t=>t&&"data"in t?t.data:t,r=r=>r.map(t),e=t=>Boolean(t&&t.children&&t.children.length),n=()=>(t=>{let r="";for(;r.length<36;)r+=Math.random().toString(36).substring(2,15);return r.slice(0,36)})(),i=t=>Array.isArray(t)&&t.length?t[0]:null,h=(t,{disallowedKeys:r=[]})=>Object.keys(t).filter(t=>!r.includes(t)).reduce((r,e)=>(r[e]=t[e],r),{}),s=t=>{const{parent:r,data:e,children:n,id:i}=t,h={data:e,children:n,id:i,parentId:null};return r&&(h.parentId=r.id),h.children=t.children.map(t=>s(t)),h},l=t=>{if(null===t)return[1];{const r=[1];let n=[t],i=[];do{for(;n.length;){const t=n.pop();e(t)&&i.push(...t.children)}i.length&&(r[r.length]=i.length),[i,n]=[n,i]}while(n.length);return r}},o=(t,r=null)=>{let n=[t],i=[];const h=[[r(t)]];do{for(;n.length;){const t=n.pop();e(t)&&i.push(...t.children)}i.length&&(h[h.length]=r?i.map(t=>r(t)):i),[i,n]=[n,i]}while(n.length);return h};class a{constructor(t=null){this.root=void 0,this.root=t,this.root=t}_traverse(t,{some:r,every:n,returnBoolean:i,returnArray:h}={},s){const l=[this.root],o=[];let a,d=!1;for(;l.length;){const i=l.shift();if(e(i)&&l[s](...i.children),r||n){const e=t(i);if(e&&h&&o.push(i),n&&!e||r&&e){d=!0,a=e;break}}else t(i)}if(n){if(i)return!d;if(h)return o}else if(r){if(i)return Boolean(a);if(h)return o}}_traverseBreathFirst(t,r){return this._traverse(t,r,"push")}_traverseDepthFirst(t,r){return this._traverse(t,r,"unshift")}traverseBreathFirst(t){this._traverseBreathFirst(t)}traverseDepthFirst(t){this._traverseDepthFirst(t)}someBreathFirst(t){return Boolean(this._traverseBreathFirst(t,{some:!0,returnBoolean:!0}))}someDepthFirst(t){return Boolean(this._traverseDepthFirst(t,{some:!0,returnBoolean:!0}))}everyBreathFirst(t){return Boolean(this._traverseDepthFirst(t,{every:!0,returnBoolean:!0}))}everyDepthFirst(t){return Boolean(this._traverseDepthFirst(t,{every:!0,returnBoolean:!0}))}findOneBreathFirst(t){const r=this._traverseBreathFirst(t,{some:!0,returnArray:!0});return i(r)}findOneDepthFirst(t){const r=this._traverseDepthFirst(t,{some:!0,returnArray:!0});return i(r)}findAllBreathFirst(t){const r=this._traverseBreathFirst(t,{every:!0,returnArray:!0});return Array.isArray(r)?r:[]}findAllDepthFirst(t){const r=this._traverseDepthFirst(t,{every:!0,returnArray:!0});return Array.isArray(r)?r:[]}flatMap(t=null){const r=[];return this._traverseBreathFirst(e=>{t&&r.push(t(e))||r.push(e)}),r}flattenData(){return this.flatMap(t)}flattenByHeight(t=null){return o(this.root,t)}flattenDataByHeight(){return this.flattenByHeight(t)}widthsByHeight(){return l(this.root)}nodesAtHeight(t){const r=this.root?[1]:[];let n=[this.root];if(r.length===t)return n;let i=[];do{for(;n.length;){const t=n.pop();e(t)&&i.push(...t.children)}if(r.length===t)return i;i.length&&(r[r.length]=i.length),[i,n]=[n,i]}while(n.length);return[]}countNodes(){return this.widthsByHeight().reduce((t,r)=>t+r,0)}maxWidth(){return Math.max(...this.widthsByHeight())}height(){return this.root?this.root.height():0}toJson(){return this.root?this.root.toJson():""}}class d{constructor(t,{id:r,parent:e}={}){this.data=void 0,this.children=[],this.id=void 0,this.value=void 0,this.label=void 0,this.parent=void 0,this.id=void 0!==r?r:n(),this.parent=e||null,this.value=r,this.label="label"in t?t.label:r,this.data=t,this.children=[]}addChild(t,{id:r}={}){const e=new d(t,{id:r,parent:this});return this.children.push(e),e}_removeChildren(t){const r=[];return this.children=this.children.filter(e=>!t(e)||(r.push(e),!1)),r}removeChildren(t){return this._removeChildren(t)}removeChildrenByData(t){return this._removeChildren(r=>r.data===t)}removeChildrenById(t){return this._removeChildren(r=>r.id===t)}isLeaf(){return null!==this.parent&&!Boolean(this.children.length)}hasChildren(){return Boolean(this.children.length)}toJson(){const t=s(this);return JSON.stringify(t)}depth(){if(this.parent){let t=0,r=this;for(;r.parent;)t+=1,r=r.parent;return t}return 0}widthsByHeight(){return l(this)}height(){return this.widthsByHeight().length-1}flattenByHeight(t=null){return o(this,t)}}const u="id",c="parentId",p="children",y=(t,{idKey:r=u,parentIdKey:e=c,childrenKey:n=p}={})=>{const i=[],h={};return t.forEach(t=>{const s=t[r],l=t[e];h[s]=h[s]||[],t[n]=h[s],l?(h[l]=h[l]||[],h[l].push(t)):i.push(t)}),i},g=(t,r=null,{idKey:e=u,parentIdKey:n=c,childrenKey:i=p}={})=>{const s=h(t,{disallowedKeys:[e,n,i]});return r?r.addChild(s,{id:t[e]}):new d(s,{id:t[e]})},f=(t,r=null,e={})=>{if(!t.length)return;const{childrenKey:n=p}=e;t.forEach(t=>{const i=g(t,r,e);f(t[n],i,e)})},v=(t,r={})=>{if(!t.length)return new a;if(t.length>1)throw new Error("Converting an array to tree only accepts an array with 0 or 1 node currently");const{childrenKey:e=p}=r,n=t[0],i=g(n,null,r),h=new a(i);return f(n[e],i,r),h},B=(t,r={})=>{const e=((t,{idKey:r,parentIdKey:e}={})=>{if(r||e){const n=[...r?[r]:[],...e?[e]:[]];return t.map(t=>{const i=h(t,{disallowedKeys:n});return r&&(i[u]=t[r]),e&&(i[c]=t[e]),i})}return t})(t,r),n=y(e);if(n.length){if(n.length=1)return v(n);throw new Error("Converting an array to tree only accepts an array with 0 or 1 node currently")}return new a};export{d as Node,a as Tree,f as createNodes,y as createTreeArrayFromFlatArray,B as createTreeFromFlatArray,v as createTreeFromTreeArray,h as filterObject,i as firstArrayElement,n as generateId,e as hasChildren,t as nodeData,r as nodesData,g as objectToNode};
//# sourceMappingURL=index.modern.mjs.map
