const t=t=>t&&"data"in t?t.data:t,e=e=>e.map(t),r=t=>Boolean(t&&t.children&&t.children.length),n=()=>(t=>{let e="";for(;e.length<36;)e+=Math.random().toString(36).substring(2,15);return e.slice(0,36)})(),i=t=>Array.isArray(t)&&t.length?t[0]:null,h=(t,{disallowedKeys:e=[]})=>Object.keys(t).filter(t=>!e.includes(t)).reduce((e,r)=>(e[r]=t[r],e),{}),s=t=>{const{parent:e,data:r,children:n,id:i,value:h,label:l}=t,o={data:r,children:n,id:i,parentId:null,value:h,label:l};return e&&(o.parentId=e.id),o.children=t.children.map(t=>s(t)),o},l=t=>{const{parent:e,data:r,children:n,id:i,value:h,label:l}=t;let o={data:r,id:i,parentId:null,value:h,label:l};return e&&(o.parentId=e.id),0!==n.length&&(o.children=t.children.map(t=>s(t))),o},o=t=>{if(null===t)return[1];{const e=[1];let n=[t],i=[];do{for(;n.length;){const t=n.pop();r(t)&&i.push(...t.children)}i.length&&(e[e.length]=i.length),[i,n]=[n,i]}while(n.length);return e}},a=(t,e=null)=>{let n=[t],i=[];const h=[[e(t)]];do{for(;n.length;){const t=n.pop();r(t)&&i.push(...t.children)}i.length&&(h[h.length]=e?i.map(t=>e(t)):i),[i,n]=[n,i]}while(n.length);return h};class d{constructor(t=null){this.root=void 0,this.root=t,this.root=t}_traverse(t,{some:e,every:n,returnBoolean:i,returnArray:h}={},s){const l=[this.root],o=[];let a,d=!1;for(;l.length;){const i=l.shift();if(r(i)&&l[s](...i.children),e||n){const r=t(i);if(r&&h&&o.push(i),n&&!r||e&&r){d=!0,a=r;break}}else t(i)}if(n){if(i)return!d;if(h)return o}else if(e){if(i)return Boolean(a);if(h)return o}}_traverseBreathFirst(t,e){return this._traverse(t,e,"push")}_traverseDepthFirst(t,e){return this._traverse(t,e,"unshift")}traverseBreathFirst(t){this._traverseBreathFirst(t)}traverseDepthFirst(t){this._traverseDepthFirst(t)}someBreathFirst(t){return Boolean(this._traverseBreathFirst(t,{some:!0,returnBoolean:!0}))}someDepthFirst(t){return Boolean(this._traverseDepthFirst(t,{some:!0,returnBoolean:!0}))}everyBreathFirst(t){return Boolean(this._traverseDepthFirst(t,{every:!0,returnBoolean:!0}))}everyDepthFirst(t){return Boolean(this._traverseDepthFirst(t,{every:!0,returnBoolean:!0}))}findOneBreathFirst(t){const e=this._traverseBreathFirst(t,{some:!0,returnArray:!0});return i(e)}findOneDepthFirst(t){const e=this._traverseDepthFirst(t,{some:!0,returnArray:!0});return i(e)}findAllBreathFirst(t){const e=this._traverseBreathFirst(t,{every:!0,returnArray:!0});return Array.isArray(e)?e:[]}findAllDepthFirst(t){const e=this._traverseDepthFirst(t,{every:!0,returnArray:!0});return Array.isArray(e)?e:[]}flatMap(t=null){const e=[];return this._traverseBreathFirst(r=>{t&&e.push(t(r))||e.push(r)}),e}flattenData(){return this.flatMap(t)}flattenByHeight(t=null){return a(this.root,t)}flattenDataByHeight(){return this.flattenByHeight(t)}widthsByHeight(){return o(this.root)}nodesAtHeight(t){const e=this.root?[1]:[];let n=[this.root];if(e.length===t)return n;let i=[];do{for(;n.length;){const t=n.pop();r(t)&&i.push(...t.children)}if(e.length===t)return i;i.length&&(e[e.length]=i.length),[i,n]=[n,i]}while(n.length);return[]}countNodes(){return this.widthsByHeight().reduce((t,e)=>t+e,0)}maxWidth(){return Math.max(...this.widthsByHeight())}height(){return this.root?this.root.height():0}toJson(){return this.root?this.root.toJson():""}toObject(){return this.root?this.root.toObject():[]}}class u{constructor(t,{id:e,parent:r}={}){this.data=void 0,this.children=[],this.id=void 0,this.value=void 0,this.label=void 0,this.parent=void 0,this.id=void 0!==e?e:n(),this.parent=r||null,this.value=e,this.label="label"in t?t.label:e,this.data=t,this.children=[]}addChild(t,{id:e}={}){const r=new u(t,{id:e,parent:this});return this.children.push(r),r}_removeChildren(t){const e=[];return this.children=this.children.filter(r=>!t(r)||(e.push(r),!1)),e}removeChildren(t){return this._removeChildren(t)}removeChildrenByData(t){return this._removeChildren(e=>e.data===t)}removeChildrenById(t){return this._removeChildren(e=>e.id===t)}isLeaf(){return null!==this.parent&&!Boolean(this.children.length)}hasChildren(){return Boolean(this.children.length)}toJson(){const t=s(this);return JSON.stringify(t)}toObject(){const t=[];if(0!==this.children.length)for(let e=0;e<this.children.length;e++)t.push(l(this.children[e]));return t}depth(){if(this.parent){let t=0,e=this;for(;e.parent;)t+=1,e=e.parent;return t}return 0}widthsByHeight(){return o(this)}height(){return this.widthsByHeight().length-1}flattenByHeight(t=null){return a(this,t)}}const c="id",p="parentId",y="children",g=(t,{idKey:e=c,parentIdKey:r=p,childrenKey:n=y}={})=>{const i=[],h={};return t.forEach(t=>{const s=t[e],l=t[r];h[s]=h[s]||[],t[n]=h[s],l?(h[l]=h[l]||[],h[l].push(t)):i.push(t)}),i},v=(t,e=null,{idKey:r=c,parentIdKey:n=p,childrenKey:i=y}={})=>{const s=h(t,{disallowedKeys:[r,n,i]});return e?e.addChild(s,{id:t[r]}):new u(s,{id:t[r]})},f=(t,e=null,r={})=>{if(!t.length)return;const{childrenKey:n=y}=r;t.forEach(t=>{const i=v(t,e,r);f(t[n],i,r)})},B=(t,e={})=>{if(!t.length)return new d;if(t.length>1)throw new Error("Converting an array to tree only accepts an array with 0 or 1 node currently");const{childrenKey:r=y}=e,n=t[0],i=v(n,null,e),h=new d(i);return f(n[r],i,e),h},F=(t,e={})=>{const r=((t,{idKey:e,parentIdKey:r}={})=>{if(e||r){const n=[...e?[e]:[],...r?[r]:[]];return t.map(t=>{const i=h(t,{disallowedKeys:n});return e&&(i[c]=t[e]),r&&(i[p]=t[r]),i})}return t})(t,e),n=g(r);if(n.length){if(n.length=1)return B(n);throw new Error("Converting an array to tree only accepts an array with 0 or 1 node currently")}return new d};export{u as Node,d as Tree,f as createNodes,g as createTreeArrayFromFlatArray,F as createTreeFromFlatArray,B as createTreeFromTreeArray,h as filterObject,i as firstArrayElement,n as generateId,r as hasChildren,t as nodeData,e as nodesData,v as objectToNode};
//# sourceMappingURL=index.modern.mjs.map
