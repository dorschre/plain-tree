{"version":3,"file":"index.umd.js","sources":["../src/utils.ts","../src/utilsNodeTree.ts","../src/Tree.ts","../src/Node.ts","../src/create.ts"],"sourcesContent":["export const nodeData = (node: any): any => {\n  return node && 'data' in node ? node.data : node;\n};\n\nexport const nodesData = (nodes: Array<any>): any => {\n  return nodes.map(nodeData);\n};\n\nexport const hasChildren = (node: any): boolean => {\n  return Boolean(node && node.children && node.children.length);\n};\n\nconst generateChars = (length: number): string => {\n  const random11Chars = (): string =>\n    Math.random()\n      .toString(36)\n      .substring(2, 15);\n  let chars = '';\n  while (chars.length < length) {\n    chars += random11Chars();\n  }\n  return chars.slice(0, length);\n};\n\nexport const generateId = (): string => {\n  return generateChars(36);\n};\n\nexport const firstArrayElement = (arr: any): any => {\n  return Array.isArray(arr) && arr.length ? arr[0] : null;\n};\n\n/*\n * Return a new object without properties in disallowedKeys\n */\nexport const filterObject = (\n  obj: object,\n  { disallowedKeys = [] }: { disallowedKeys: Array<string> }\n): object => {\n  const filteredObj = Object.keys(obj)\n    .filter(key => !disallowedKeys.includes(key))\n    .reduce((o, key) => {\n      o[key] = obj[key];\n      return o;\n    }, {});\n  return filteredObj;\n};\n","/*\n * Common Node and Tree utilities\n */\nimport { NodeOrNull, SerializedLeaf, SerializedNode } from './types';\nimport { hasChildren } from './utils';\nimport Node from './Node';\n\nexport const nodeToJsonFormatter = (node: Node): SerializedNode => {\n  const { parent, data, children, id, value, label } = node;\n\n  const obj: SerializedNode = {\n    data,\n    children,\n    id,\n    parentId: null,\n    value,\n    label\n  };\n\n  parent && (obj.parentId = parent.id);\n\n  obj.children = (node.children as Node[]).map(\n    (child: Node): SerializedNode => nodeToJsonFormatter(child)\n  );\n  return obj;\n};\n\nexport const nodeToObjectFormatter = (node: Node): any => {\n  const { parent, data, children, id, value, label } = node;\n  let obj: any = {\n    data,\n    id,\n    parentId: null,\n    value,\n    label\n  };\n\n  parent && (obj.parentId = parent.id);\n  if(children.length !== 0){\n    obj.children = (node.children as Node[]).map(\n      (child: Node): any => nodeToObjectFormatter(child)\n    );\n  }\n\n\n\n  return obj;\n};\n\nexport const widthsByHeight = (node: NodeOrNull): Array<number> => {\n  if (node === null) {\n    return [1];\n  } else {\n    const counter = [1];\n    let currentQueue = [node];\n    let nextQueue: NodeOrNull[] = [];\n    do {\n      while (currentQueue.length) {\n        const node = currentQueue.pop();\n        hasChildren(node) && nextQueue.push(...node.children);\n      }\n      if (nextQueue.length) {\n        counter[counter.length] = nextQueue.length;\n      }\n      [nextQueue, currentQueue] = [currentQueue, nextQueue];\n    } while (currentQueue.length);\n    return counter;\n  }\n};\n\nexport const flattenByHeight = (\n  node: NodeOrNull,\n  fn: Function | null = null\n): any[][] => {\n  let currentQueue = [node];\n  let nextQueue: NodeOrNull[] = [];\n  const result = [[fn(node)]];\n  do {\n    while (currentQueue.length) {\n      const node = currentQueue.pop();\n      hasChildren(node) && nextQueue.push(...node.children);\n    }\n    if (nextQueue.length) {\n      // explicit argument passing to fn to placate TypeScript\n      if (fn) {\n        result[result.length] = nextQueue.map(node => fn(node));\n      } else {\n        result[result.length] = nextQueue;\n      }\n    }\n    [nextQueue, currentQueue] = [currentQueue, nextQueue];\n  } while (currentQueue.length);\n  return result;\n};\n","import Node from './Node';\nimport { nodeData, hasChildren, firstArrayElement } from './utils';\nimport { widthsByHeight, flattenByHeight } from './utilsNodeTree';\nimport { NodeOrNull } from './types';\n\ntype TraverseReturn = void | boolean | Array<NodeOrNull>;\ntype TraverseOptions = {\n  some?: boolean;\n  every?: boolean;\n  returnBoolean?: boolean;\n  returnArray?: boolean;\n};\n\nclass Tree {\n  constructor(public root: NodeOrNull = null) {\n    this.root = root;\n  }\n\n  private _traverse(\n    fn: Function,\n    { some, every, returnBoolean, returnArray }: TraverseOptions = {},\n    queueMethod: string\n  ): TraverseReturn {\n    const queue = [this.root];\n    const results: Array<NodeOrNull> = [];\n    let didBreak = false;\n    let lastResult: undefined | boolean;\n    while (queue.length) {\n      const node = queue.shift();\n      hasChildren(node) && queue[queueMethod](...node.children);\n      if (some || every) {\n        const result = fn(node);\n        if (result && returnArray) {\n          results.push(node);\n        }\n        if ((every && !result) || (some && result)) {\n          didBreak = true;\n          lastResult = result;\n          break;\n        }\n      } else {\n        fn(node);\n      }\n    }\n    if (every) {\n      if (returnBoolean) {\n        return !didBreak;\n      } else if (returnArray) {\n        return results;\n      }\n    } else if (some) {\n      if (returnBoolean) {\n        return Boolean(lastResult);\n      } else if (returnArray) {\n        return results;\n      }\n    }\n  }\n\n  private _traverseBreathFirst(\n    fn: Function,\n    opts?: TraverseOptions\n  ): TraverseReturn {\n    return this._traverse(fn, opts, 'push');\n  }\n\n  private _traverseDepthFirst(\n    fn: Function,\n    opts?: TraverseOptions\n  ): TraverseReturn {\n    return this._traverse(fn, opts, 'unshift');\n  }\n\n  traverseBreathFirst(fn: Function): TraverseReturn {\n    this._traverseBreathFirst(fn);\n  }\n\n  /*\n   * Hit the bottom of the tree as fast as possible\n   * Then go up and get parent's children, then go down again\n   */\n  traverseDepthFirst(fn: Function): TraverseReturn {\n    this._traverseDepthFirst(fn);\n  }\n\n  /*\n   * Return true if a single node is truthy for fn, else false\n   * exit early on first truthy value\n   */\n  someBreathFirst(fn: Function): boolean {\n    return Boolean(\n      this._traverseBreathFirst(fn, {\n        some: true,\n        returnBoolean: true\n      })\n    );\n  }\n\n  /*\n   * Return true if a single node is truthy for fn, else false\n   * exit early on first truthy value\n   */\n  someDepthFirst(fn: Function): boolean {\n    return Boolean(\n      this._traverseDepthFirst(fn, {\n        some: true,\n        returnBoolean: true\n      })\n    );\n  }\n\n  /*\n   * Return true if result of function for every node is truthy\n   * exit early on first function falsey value\n   */\n  everyBreathFirst(fn: Function): boolean {\n    return Boolean(\n      this._traverseDepthFirst(fn, {\n        every: true,\n        returnBoolean: true\n      })\n    );\n  }\n\n  /*\n   * Return true if result of function for every node is truthy\n   * exit early on first function falsey value\n   */\n  everyDepthFirst(fn: Function): boolean {\n    return Boolean(\n      this._traverseDepthFirst(fn, { every: true, returnBoolean: true })\n    );\n  }\n\n  findOneBreathFirst(fn: Function): NodeOrNull {\n    const result = this._traverseBreathFirst(fn, {\n      some: true,\n      returnArray: true\n    });\n    return firstArrayElement(result);\n  }\n\n  findOneDepthFirst(fn: Function): NodeOrNull {\n    const result = this._traverseDepthFirst(fn, {\n      some: true,\n      returnArray: true\n    });\n    return firstArrayElement(result);\n  }\n\n  findAllBreathFirst(fn: Function): Array<NodeOrNull> {\n    const result = this._traverseBreathFirst(fn, {\n      every: true,\n      returnArray: true\n    });\n    return Array.isArray(result) ? result : [];\n  }\n\n  findAllDepthFirst(fn: Function): Array<NodeOrNull> {\n    const result = this._traverseDepthFirst(fn, {\n      every: true,\n      returnArray: true\n    });\n    return Array.isArray(result) ? result : [];\n  }\n\n  flatMap(fn: Function | null = null): Array<any> {\n    const acc: Array<any> = [];\n    this._traverseBreathFirst((node: Node) => {\n      (fn && acc.push(fn(node))) || acc.push(node);\n    });\n    return acc;\n  }\n\n  flattenData(): Array<any> {\n    return this.flatMap(nodeData);\n  }\n\n  flattenByHeight(fn: Function | null = null): any[][] {\n    return flattenByHeight(this.root, fn);\n  }\n\n  flattenDataByHeight(): any[][] {\n    return this.flattenByHeight(nodeData);\n  }\n\n  /*\n   * Get the width of each height of the tree from top to bottom\n   */\n  widthsByHeight(): Array<number> {\n    return widthsByHeight(this.root);\n  }\n\n  /*\n   * Root has height 0\n   */\n  nodesAtHeight(height: number): Array<NodeOrNull> {\n    const counter = this.root ? [1] : [];\n    let currentQueue = [this.root];\n    if (counter.length === height) {\n      return currentQueue;\n    }\n    let nextQueue: NodeOrNull[] = [];\n    do {\n      while (currentQueue.length) {\n        const node = currentQueue.pop();\n        hasChildren(node) && nextQueue.push(...node.children);\n      }\n      if (counter.length === height) {\n        return nextQueue;\n        break;\n      } else {\n        if (nextQueue.length) {\n          counter[counter.length] = nextQueue.length;\n        }\n        [nextQueue, currentQueue] = [currentQueue, nextQueue];\n      }\n    } while (currentQueue.length);\n    return [];\n  }\n\n  countNodes(): number {\n    return this.widthsByHeight().reduce((acc, curr) => acc + curr, 0);\n  }\n\n  maxWidth(): number {\n    return Math.max(...this.widthsByHeight());\n  }\n\n  height(): number {\n    return this.root ? this.root.height() : 0;\n  }\n\n  toJson(): string {\n    return this.root ? this.root.toJson() : '';\n  }\n\n  toObject(): any {\n    return this.root ? this.root.toObject() : [];\n  }\n}\n\nexport default Tree;\n","import { generateId } from './utils';\nimport {\n  nodeToJsonFormatter,\n  nodeToObjectFormatter,\n  widthsByHeight,\n  flattenByHeight\n} from './utilsNodeTree';\nimport { NodeOrNull } from './types';\n\nclass Node {\n  data: any;\n  children: Node[] = [];\n  id: string;\n  value: string;\n  label: string;\n  parent: NodeOrNull;\n\n  constructor(\n    data: any,\n    { id, parent }: { id?: string; parent?: NodeOrNull } = {}\n  ) {\n    this.id = id !== undefined ? id : generateId();\n    this.parent = parent || null;\n    \n    this.value = id;\n    if (\"label\" in data){\n    this.label = data.label;\n    } else {this.label = id}\n    this.data = data;\n    this.children = [];\n  }\n\n  addChild(data: any, { id }: { id?: string } = {}): Node {\n    const node = new Node(data, { id, parent: this });\n    this.children.push(node);\n    return node;\n  }\n\n  private _removeChildren(fn: Function): Array<Node> {\n    const removedChildren: Array<Node> = [];\n    this.children = this.children.filter(node => {\n      if (fn(node)) {\n        removedChildren.push(node);\n        return false;\n      }\n      return true;\n    });\n    return removedChildren;\n  }\n\n  removeChildren(fn: Function): Array<Node> {\n    return this._removeChildren(fn);\n  }\n\n  removeChildrenByData(data: any): Array<Node> {\n    const fn: Function = (node: Node) => node.data === data;\n    return this._removeChildren(fn);\n  }\n\n  removeChildrenById(id: string): Array<Node> {\n    const fn: Function = (node: Node) => node.id === id;\n    return this._removeChildren(fn);\n  }\n\n  isLeaf(): boolean {\n    return this.parent !== null && !Boolean(this.children.length);\n  }\n\n  hasChildren(): boolean {\n    return Boolean(this.children.length);\n  }\n\n  toJson(): string {\n    const objectToSerialize = nodeToJsonFormatter(this);\n\n    return JSON.stringify(objectToSerialize);\n  }\n\n  toObject(): any {\n    const res = [];\n    if(this.children.length !== 0 ){\n      for (let id = 0; id < this.children.length; id++){\n        res.push(nodeToObjectFormatter(this.children[id]))\n      }\n    }\n    return res;\n  }\n\n  depth(): number {\n    if (!this.parent) {\n      return 0;\n    } else {\n      let depth = 0;\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      let currentNode: Node = this;\n      while (currentNode.parent) {\n        depth += 1;\n        currentNode = currentNode.parent;\n      }\n      return depth;\n    }\n  }\n\n  widthsByHeight(): Array<number> {\n    return widthsByHeight(this);\n  }\n\n  height(): number {\n    return this.widthsByHeight().length - 1;\n  }\n\n  flattenByHeight(fn: Function | null = null): any[][] {\n    return flattenByHeight(this, fn);\n  }\n}\n\nexport default Node;\n","import {\n  NodeOrNull,\n  CreateOptions,\n  CreateOptionsWithCustomChildrenKey,\n  ObjectAnyProperties\n} from './types';\nimport Tree from './Tree';\nimport Node from './Node';\nimport { filterObject } from './utils';\n\nconst ID_KEY_DEFAULT = 'id';\nconst PARENT_ID_KEY_DEFAULT = 'parentId';\nconst CHILDREN_KEY_DEFAULT = 'children';\n\n/*\n * Create an array of objects representing a tree\n * Return array (as tree may have multiple roots).\n * Takes a flat array that looks like this:\n * [\n *   {\n *     id: 'sports',\n *     name: 'Sports',\n *     parentId: null\n *   },\n *   {\n *     id: 'ball',\n *     name: 'Ball',\n *     parentId: 'sports'\n *   },\n *   {\n *     id: 'non-ball',\n *     name: 'Non Ball',\n *     parentId: 'sports'\n *   },\n *   {\n *     id: 'tennis',\n *     name: 'Tennis',\n *     parentId: 'ball'\n *   }\n * ];\n * Returns a tree array that looks like this\n * [\n *   {\n *     \"id\": \"sports\",\n *     \"name\": \"Sports\",\n *     \"parentId\": null,\n *     \"children\": [\n *       {\n *         \"id\": \"ball\",\n *         \"name\": \"Ball\",\n *         \"parentId\": \"sports\",\n *         \"children\": [\n *           {\n *             \"id\": \"tennis\",\n *             \"name\": \"Tennis\",\n *             \"parentId\": \"ball\",\n *             \"children\": []\n *           }\n *         ]\n *       },\n *       {\n *         \"id\": \"non-ball\",\n *         \"name\": \"Non Ball\",\n *         \"parentId\": \"sports\",\n *         \"children\": []\n *       }\n *     ]\n *   }\n * ]\n */\nexport const createTreeArrayFromFlatArray = (\n  data: Array<ObjectAnyProperties>,\n  {\n    idKey = ID_KEY_DEFAULT,\n    parentIdKey = PARENT_ID_KEY_DEFAULT,\n    childrenKey = CHILDREN_KEY_DEFAULT\n  }: CreateOptionsWithCustomChildrenKey = {}\n): Array<ObjectAnyProperties> => {\n  const treeArray: Array<ObjectAnyProperties> = [];\n  const childrenOf = {};\n  data.forEach((obj: any) => {\n    const id = obj[idKey];\n    const parentId = obj[parentIdKey];\n    // obj may have children\n    childrenOf[id] = childrenOf[id] || [];\n    // init obj's children\n    obj[childrenKey] = childrenOf[id];\n    if (parentId) {\n      // init obj's parent's children object\n      childrenOf[parentId] = childrenOf[parentId] || [];\n      // push obj into its parent's children object\n      childrenOf[parentId].push(obj);\n    } else {\n      treeArray.push(obj);\n    }\n  });\n  return treeArray;\n};\n\n/*\n * Take an object that looks like a node, and turn it into a node.\n * Take all properties from obj that aren't in disallowedKeys and set as\n * 'data' on the node.\n */\nexport const objectToNode = (\n  obj: object,\n  parent: NodeOrNull = null,\n  {\n    idKey = ID_KEY_DEFAULT,\n    parentIdKey = PARENT_ID_KEY_DEFAULT,\n    childrenKey = CHILDREN_KEY_DEFAULT\n  }: CreateOptionsWithCustomChildrenKey = {}\n): Node => {\n  const disallowedKeys = [idKey, parentIdKey, childrenKey];\n  const data = filterObject(obj, { disallowedKeys });\n  if (parent) {\n    return parent.addChild(data, { id: obj[idKey] });\n  } else {\n    return new Node(data, { id: obj[idKey] });\n  }\n};\n\n/*\n * Create a node for each element in an array, then recursively create child nodes\n */\nexport const createNodes = (\n  data: Array<ObjectAnyProperties>,\n  parentNode: NodeOrNull = null,\n  opts: CreateOptionsWithCustomChildrenKey = {}\n): void => {\n  if (!data.length) {\n    return;\n  }\n  const { childrenKey = CHILDREN_KEY_DEFAULT } = opts;\n  data.forEach(obj => {\n    const node = objectToNode(obj, parentNode, opts);\n    // create all the nodes for the children of this node, with this node as parent\n    createNodes(obj[childrenKey], node, opts);\n  });\n};\n\n/*\n * Tree array to supply (example):\n * [\n *   {\n *     \"id\": \"sports\",\n *     \"name\": \"Sports\",\n *     \"parentId\": null,\n *     \"children\": [\n *       {\n *         \"id\": \"ball\",\n *         \"name\": \"Ball\",\n *         \"parentId\": \"sports\",\n *         \"children\": [\n *           {\n *             \"id\": \"tennis\",\n *             \"name\": \"Tennis\",\n *             \"parentId\": \"ball\",\n *             \"children\": []\n *           }\n *         ]\n *       },\n *       {\n *         \"id\": \"non-ball\",\n *         \"name\": \"Non Ball\",\n *         \"parentId\": \"sports\",\n *         \"children\": []\n *       }\n *     ]\n *   }\n * ]\n * Return a Tree instance\n */\nexport const createTreeFromTreeArray = (\n  data: Array<ObjectAnyProperties>,\n  opts: CreateOptionsWithCustomChildrenKey = {}\n): Tree => {\n  if (!data.length) {\n    return new Tree();\n  } else if (data.length > 1) {\n    // TODO: add this feature\n    throw new Error(\n      'Converting an array to tree only accepts an array with 0 or 1 node currently'\n    );\n  }\n  const { childrenKey = CHILDREN_KEY_DEFAULT } = opts;\n  const rootObj = data[0];\n  const root = objectToNode(rootObj, null, opts);\n  const tree = new Tree(root);\n  createNodes(rootObj[childrenKey], root, opts);\n  return tree;\n};\n\n/*\n * Map the supplied array of objects to what is required required for Node creation\n */\nconst mapFlatArray = (\n  data: Array<ObjectAnyProperties>,\n  { idKey, parentIdKey }: CreateOptions = {}\n): Array<ObjectAnyProperties> => {\n  if (idKey || parentIdKey) {\n    const disallowedKeys = [\n      ...(idKey ? [idKey] : []),\n      ...(parentIdKey ? [parentIdKey] : [])\n    ];\n    return data.map(obj => {\n      const newObj = filterObject(obj, { disallowedKeys });\n      idKey && (newObj[ID_KEY_DEFAULT] = obj[idKey]);\n      parentIdKey && (newObj[PARENT_ID_KEY_DEFAULT] = obj[parentIdKey]);\n      return newObj;\n    });\n  }\n  return data;\n};\n\n/*\n * Flat array to supply example:\n * [\n *   {\n *     id: 'sports',\n *     name: 'Sports',\n *     parentId: null\n *   },\n *   {\n *     id: 'ball',\n *     name: 'Ball',\n *     parentId: 'sports'\n *   },\n *   {\n *     id: 'non-ball',\n *     name: 'Non Ball',\n *     parentId: 'sports'\n *   },\n *   {\n *     id: 'tennis',\n *     name: 'Tennis',\n *     parentId: 'ball'\n *   }\n * ];\n */\nexport const createTreeFromFlatArray = (\n  data: Array<ObjectAnyProperties>,\n  opts: CreateOptions = {}\n): any => {\n  const mappedFlatArray = mapFlatArray(data, opts);\n  const treeArray: Array<ObjectAnyProperties> = createTreeArrayFromFlatArray(\n    mappedFlatArray\n  );\n  if (!treeArray.length) {\n    return new Tree();\n  } else if ((treeArray.length = 1)) {\n    return createTreeFromTreeArray(treeArray);\n  } else {\n    // TODO: add functionality\n    throw new Error(\n      'Converting an array to tree only accepts an array with 0 or 1 node currently'\n    );\n  }\n};\n"],"names":["nodeData","node","data","hasChildren","Boolean","children","length","generateId","chars","Math","random","toString","substring","slice","generateChars","firstArrayElement","arr","Array","isArray","filterObject","obj","disallowedKeys","_ref$disallowedKeys","Object","keys","filter","key","includes","reduce","o","nodeToJsonFormatter","parent","id","parentId","value","label","map","child","nodeToObjectFormatter","widthsByHeight","counter","currentQueue","_nextQueue","_node","pop","nextQueue","push","apply","_ref","flattenByHeight","fn","_nextQueue2","_node2","result","_ref2","Tree","root","this","_proto","prototype","_traverse","_temp","queueMethod","lastResult","some","every","returnBoolean","returnArray","results","queue","shift","didBreak","_traverseBreathFirst","opts","_traverseDepthFirst","traverseBreathFirst","traverseDepthFirst","someBreathFirst","someDepthFirst","everyBreathFirst","everyDepthFirst","findOneBreathFirst","findOneDepthFirst","findAllBreathFirst","findAllDepthFirst","flatMap","acc","flattenData","_flattenByHeight","flattenDataByHeight","_widthsByHeight","nodesAtHeight","height","countNodes","curr","maxWidth","max","toJson","toObject","Node","undefined","addChild","_temp2","_removeChildren","removedChildren","removeChildren","removeChildrenByData","removeChildrenById","isLeaf","objectToSerialize","JSON","stringify","res","depth","currentNode","ID_KEY_DEFAULT","PARENT_ID_KEY_DEFAULT","CHILDREN_KEY_DEFAULT","createTreeArrayFromFlatArray","idKey","_ref$idKey","_ref$parentIdKey","parentIdKey","childrenKey","_ref$childrenKey","treeArray","childrenOf","forEach","objectToNode","_ref2$idKey","_ref2$parentIdKey","_ref2$childrenKey","createNodes","parentNode","_opts$childrenKey","_opts2$childrenKey","rootObj","tree","mappedFlatArray","_temp3","_ref3","newObj","mapFlatArray","createTreeFromTreeArray","Error","nodes"],"mappings":"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"}